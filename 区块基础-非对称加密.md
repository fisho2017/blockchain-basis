# 区块基础-非对称加密

标签（空格分隔）： 磨链入门区块链

非对称加密：

和之前的对称加密对比，非对称加密使用一对密钥，即公钥和私钥，自己保存私钥，公钥公开，允许在不安全的媒体上通讯双方交换信息，也成为公钥加密。非对称加密是现代密码学的重要突破，现在最为知名的就是RSA公钥加密算法。

RSA算法：

数学原理：

在说明RSA算法之前稍微了解下一些基本数学知识：

质数：prime number，又称为素数，在大于1的自然数中，除了1和其本身，没有其他因素，这种数就称为质数。（2.3.5.7.11.13.17.19，这是20以内的质数）

互质关系：coprime，两个正整数，除了1之外没有其他的公因子，这两个数就是互质关系。通过互质关系可以推导出几个原理：（p、q、n为正整数）

    p、q为质数、那么p、q互质关系。任意两个质数构成互质关系。这个比较容易理解，两个质数没有公因子，自然能形成互质关系。

    q和p≠nq，p、q互质关系。一个质数和该质数的非倍数，质数只能被1和其本身整除，那么其非倍数的数自然和其形成互质关系。

    q＞p，q为质数，q、p互质。两个数，较大一个为质数，那么这两个数也是互质关系。

    p＞1，p和p-1为互质关系。

    p＞1且p为奇数，p和p-2为互质关系。

    p=1，p和任意正整数都是互质关系。

欧拉函数：
![11.png-1.7kB][1]

给定一个正整数n，那么小于n的正整数中，有多少个正整数和n构成互质关系。欧拉函数的证明过程比较复杂，这里简单说明几个定理：（n为正整数、p为质数、k为＞1的正整数）

    n=1，那么φ(n)=1。

    n为质数，φ(n)=n-1。

    n是一个质数的几次方，那么n=p的k次方，那么φ(n)=p^k-p^(k-1)=(p-1)p^(k-1)。例：φ(8)=2^3-2^2=1*2^(3-1)=4（1、3、5、7）

    n=p*p’那么φ(n)=φ(p*p’)=φ(p)*φ(p’)。例：φ(15)=φ(3)φ(5)=2*4=8（1、2、4、7、8、11、13、14）

    n为奇数，那么φ(n)=φ(2n)。

模反元素：
![12.png-2.3kB][2]

如果两个正整数a和n互质，那么一定可以找到整数b，使得 ab-1 被n整除，或者说ab被n除的余数是1。这时，b就叫做a的“模反元素”。

例：3和11互质，那么3的模反元素就是4，因为 (3 × 4)-1 可以被11整除。显然，模反元素不止一个， 4加减11的整数倍都是3的模反元素 {...,-18,-7,4,15,26,...}，即如果b是a的模反元素，则 b+kn 都是a的模反元素。欧拉定义可以用来证明模反元素的存在性：
![13.png-3kB][3]

RSA算法简介：

RSA算法是一种非对称密码算法，所谓非对称，就是指该算法需要一对密钥，使用其中一个加密，则需要用另一个才能解密。RSA的算法涉及三个参数，n、e1、e2。其中，n是两个大质数p、q的积，n的二进制表示时所占用的位数，就是所谓的密钥长度。e1和e2是一对相关的值，e1可以任意取，但要求e1与(p-1)*(q-1)互质；再选择e2，要求(e2*e1)mod((p-1)*(q-1))=1。（n，e1),(n，e2)就是密钥对。其中(n，e1)为公钥，(n，e2)为私钥。RSA加解密的算法完全相同，设A为明文，B为密文，则：A=B^e2 mod n；B=A^e1 mod n；（公钥加密体制中，一般用公钥加密，私钥解密）e1和e2可以互换使用，即：A=B^e1 mod n；B=A^e2 mod n。

例：通过一个加解密过程来说明：

A和B两个加解密交互，A首先选择一对质数，因为是举例所以选择数比较小，实际中根据质数位数，安全性有相应的提升，一般小位的RSA算法已可通过暴力破解来解密，所以实际应用中位数选择也是很重要的，根据位数来设置安全权限等级高低。

A选择一对质数，x、y，然后将x*y=z，把z写成二进制表达（二进制位数决定安全性高低）。

根据欧拉函数计算，p=（x-1）*（y-1）

随机选择一个整数q，1<q<p，p和q互质

结合模反元素计算d的值，ed ≡ 1 (mod φ(n))--ed - 1 = kφ(n)--ex + φ(n)y = 1（推导计算），实际就理解q*x+p*y=1。（欧几里得算法）

刚刚计算的那些值：z、p、q、d，封装下（z、q）公钥，（z、d）私钥。

上面就是整个公钥和私钥的生成。任何算法都要考虑他的逆推时候会可行。

私钥中的d是关键的数字，那么已知（z、q）推导d，由于q是随机选择的，z又和私钥相关，可知z能否逆推变得很重要。分析下z：

z因数分解（把一个整数分解成两个或更多的除1外的整数相乘的过程），我们假设一个16：（2-8、2-2-4、4-4等），那么你选择一个4位数或者8位数，测试下能计算出多少种可能，再结合现实场景一个16位以上乘以16位以上，你再计算他的因数分解。这个难度值还是比较高的。

结合加解密过程再说明：

首先是加密，选择一个数字加密，数字为m 那么加密：m的q次方=加密后值（mod z）。解密，加密后的值的d次方=m（mod z），解密后m和之前m一致。

附密钥长度的安全级别：
![14.png-21.4kB][4]


  [1]: http://static.zybuluo.com/JackyJin/39mau5p4l0sc2uimncctaj94/11.png
  [2]: http://static.zybuluo.com/JackyJin/vh0akjrfpnarl32s46aite9n/12.png
  [3]: http://static.zybuluo.com/JackyJin/qkjl3xhdpb4py6lni26v3fp9/13.png
  [4]: http://static.zybuluo.com/JackyJin/evl1l3jsduutnj8sx9c7igij/14.png